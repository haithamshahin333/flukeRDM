trip_data <- trip_data[base_outcomes, on = .(date_parsed, mode, tripid, catch_draw), nomatch = 0]
trip_data[, domain2 := NULL]
rm(sf_trip_data, scup_trip_data, bsb_trip_data,
size_data_sf, size_data_bsb,size_data_scup,
base_outcomes, catch_data)
#trip_data$NJ_dummy<-case_when(s=="NJ"~1, TRUE~0)
# compute utility/choice probabilites/welfare
# Convert to data.table if not already
data.table::setDT(trip_data)
# Precompute square roots once
trip_data[, `:=`(
sqrt_keep_sf_new = sqrt(tot_keep_sf_new),
sqrt_rel_sf_new = sqrt(tot_rel_sf_new),
sqrt_keep_bsb_new = sqrt(tot_keep_bsb_new),
sqrt_rel_bsb_new = sqrt(tot_rel_bsb_new),
sqrt_keep_sf_base = sqrt(tot_keep_sf_base),
sqrt_rel_sf_base = sqrt(tot_rel_sf_base),
sqrt_keep_bsb_base = sqrt(tot_keep_bsb_base),
sqrt_rel_bsb_base = sqrt(tot_rel_bsb_base),
sqrt_cat_scup_new = sqrt(tot_cat_scup_new),
sqrt_cat_scup_base = sqrt(tot_cat_scup_base)
)]
# Compute vA and v0
trip_data[, `:=`(
vA = beta_sqrt_sf_keep * sqrt_keep_sf_new +
#beta_NJ_sf_keep*NJ_dummy +
beta_sqrt_sf_release * sqrt_rel_sf_new +
beta_sqrt_bsb_keep * sqrt_keep_bsb_new +
beta_sqrt_bsb_release * sqrt_rel_bsb_new +
beta_sqrt_sf_bsb_keep * (sqrt_keep_sf_new * sqrt_keep_bsb_new) +
beta_sqrt_scup_catch * sqrt_cat_scup_new +
beta_cost * cost,
v0 = beta_sqrt_sf_keep * sqrt_keep_sf_base +
#beta_NJ_sf_keep*NJ_dummy +
beta_sqrt_sf_release * sqrt_rel_sf_base +
beta_sqrt_bsb_keep * sqrt_keep_bsb_base +
beta_sqrt_bsb_release * sqrt_rel_bsb_base +
beta_sqrt_sf_bsb_keep * (sqrt_keep_sf_base * sqrt_keep_bsb_base) +
beta_sqrt_scup_catch * sqrt_cat_scup_base +
beta_cost * cost
)]
# remove the temp sqrt columns to save memory
trip_data[, c("sqrt_keep_sf_new", "sqrt_rel_sf_new", "sqrt_keep_bsb_new", "sqrt_rel_bsb_new",
"sqrt_keep_sf_base", "sqrt_rel_sf_base", "sqrt_keep_bsb_base", "sqrt_rel_bsb_base",
"sqrt_cat_scup_new", "sqrt_cat_scup_base") := NULL]
mean(trip_data$tot_cat_sf_base)
mean(trip_data$tot_cat_sf_new)
mean(trip_data$tot_cat_bsb_base)
mean(trip_data$tot_cat_bsb_new)
mean(trip_data$tot_cat_scup_base)
mean(trip_data$tot_cat_scup_new)
mean(trip_data$tot_keep_sf_base)
mean(trip_data$tot_keep_sf_new)
mean(trip_data$tot_rel_sf_base)
mean(trip_data$tot_rel_sf_new)
mean(trip_data$tot_keep_bsb_base)
mean(trip_data$tot_keep_bsb_new)
mean(trip_data$tot_keep_scup_base)
mean(trip_data$tot_keep_scup_new)
View(calib_lookup)
sf_size_data <- sf_size_data[mode == md]
View(sf_size_data)
# Data read for non-shiny run of predict_rec_catch.R
## Run this script prior to predict rec catch
#Lou's repos
iterative_input_data_cd="E:/Lou's projects/flukeRDM/flukeRDM_iterative_data"
input_data_cd="C:/Users/andrew.carr-harris/Desktop/MRIP_data_2025"
#check
############# To Run Individual
# Variables to change
#dr<-1
#st="NJ"
ndraws=50 #number of choice occasions to simulate per strata
library(magrittr)
############# To Run in Loop
#for (st in c("MA", "RI", "CT", "NY", "NJ", "DE", "MD", "VA", "NC")){
#  for (dr in 1:2){
# import necessary data
# For kim: We need to retain the SQ regulation variables.
#          As of now, the SQ regulations variables are the ones without subscripts.
#          I will copy these variables with the subscript _SQ to make this explicit.
#          The alternative regulations that will be adjusted by the users will be
#          have subscripts _y2 (note this is slightly different from cod and haddock 2024)
directed_trips<-feather::read_feather(file.path(iterative_input_data_cd, paste0("directed_trips_calibration_new_", st, ".feather"))) %>%
tibble::tibble() %>%
dplyr::filter(draw == dr) %>%
dplyr::select(mode, date,
bsb_bag, bsb_min, bsb_bag_y2, bsb_min_y2,
fluke_bag, fluke_min, fluke_bag_y2,fluke_min_y2,
scup_bag, scup_min, scup_bag_y2, scup_min_y2) %>%
dplyr::mutate(fluke_min_SQ=fluke_min, fluke_bag_SQ=fluke_bag,
bsb_min_SQ=bsb_min, bsb_bag_SQ=bsb_bag,
scup_min_SQ=scup_min, scup_bag_SQ=scup_bag)
#catch_data <- feather::read_feather(file.path(iterative_input_data_cd, paste0("proj_catch_draws_",st, "_", dr,".feather"))) %>%
#  dplyr::left_join(directed_trips, by=c("mode", "date"))
l_w_conversion <- readr::read_csv(file.path("C:/Users/andrew.carr-harris/Desktop/Git/flukeRDM/Data", "L_W_Conversion.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state==st)
# sf_size_data <- read_csv(file.path(iterative_input_data_cd, "projected_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
#   dplyr::filter(state == st, species=="sf", draw==dr) %>%
#   dplyr::filter(!is.na(fitted_prob)) %>%
#   dplyr::select(state, fitted_prob, length, mode)
#
# bsb_size_data <- read_csv(file.path(iterative_input_data_cd, "projected_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
#   dplyr::filter(state == st, species=="bsb" , draw==dr) %>%
#   dplyr::filter(!is.na(fitted_prob)) %>%
#   dplyr::select(state, fitted_prob, length, mode)
#
# scup_size_data <- read_csv(file.path(iterative_input_data_cd, "projected_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
#   dplyr::filter(state == st, species=="scup", draw==dr) %>%
#   dplyr::filter(!is.na(fitted_prob)) %>%
#   dplyr::select(state,  fitted_prob, length, mode)
calendar_adjustments <- readr::read_csv(
file.path(iterative_input_data_cd, paste0("proj_year_calendar_adjustments_new_", st, ".csv")), show_col_types = FALSE) %>%
dplyr::select(-state.y) %>%
dplyr::rename(state=state.x) %>%
dplyr::filter(state == st, draw==dr) %>%
dplyr::select(-dtrip, -dtrip_y2, -state, -draw)
# base-year trip outcomes
base_outcomes0 <- list()
n_choice_occasions0 <- list()
mode_draw <- c("sh", "pr", "fh")
for (md in mode_draw) {
# pull trip outcomes from the calibration year
base_outcomes0[[md]]<-feather::read_feather(file.path(iterative_input_data_cd, paste0("base_outcomes_new_", st, "_", md, "_", dr, ".feather"))) %>%
data.table::as.data.table()
base_outcomes0[[md]]<-base_outcomes0[[md]] %>%
dplyr::select(-domain2) %>%
dplyr::mutate(date_parsed=lubridate::dmy(date)) %>%
dplyr::select(-date)
# pull in data on the number of choice occasions per mode-day
n_choice_occasions0[[md]]<-feather::read_feather(file.path(iterative_input_data_cd, paste0("n_choice_occasions_new_", st,"_", md, "_", dr, ".feather")))
n_choice_occasions0[[md]]<-n_choice_occasions0[[md]] %>%
dplyr::mutate(date_parsed=lubridate::dmy(date)) %>%
dplyr::select(-date)
}
base_outcomes <- bind_rows(base_outcomes0)
n_choice_occasions <- bind_rows(n_choice_occasions0) %>%
dplyr::arrange(date_parsed, mode)
rm(base_outcomes0, n_choice_occasions0)
base_outcomes<-base_outcomes %>%
dplyr::arrange(date_parsed, mode, tripid, catch_draw)
catch_data <- base_outcomes %>%
dplyr::mutate(date_obj = as.Date(date_parsed, format = "%Y-%m-%d")) %>%
dplyr::mutate(date = format(date_obj, format = "%d%b%Y")|> tolower()) %>%
dplyr::select(-matches("beta")) %>%
dplyr::rename(sf_cat=tot_cat_sf_base, bsb_cat=tot_cat_bsb_base, scup_cat=tot_cat_scup_base) %>%
dplyr::select(-cost, -NJ_dummy, -age, -date_parsed, -date_obj,-total_trips_12, -matches("tot_keep"), -matches("tot_rel") ) %>%
dplyr::left_join(directed_trips, by=c("mode", "date"))
# Projected catch-at-length *note for Kim that this file now contains distn's by mode
# statez <- c("MA", "RI", "CT", "NY", "NJ", "DE", "MD", "VA", "NC")
# modez <- c("sh", "pr", "fh")
# length_draw_list<-list()
# length_draws_st_list<-list()
# for(st in statez){
#   for(md in modez){
#
#     good_draws<-read_excel(file.path(iterative_input_data_cd, "calibration_good_draws.xlsx")) %>%
#       dplyr::filter(state==st & mode==md)
#
#     length_draw_list[[md]][[st]]<-read_csv(file.path(iterative_input_data_cd, "baseline_catch_at_length.csv"), show_col_types = FALSE) %>%
#       dplyr::filter(state==st) %>%
#       dplyr::left_join(good_draws, by=c("state", "draw")) %>%
#       dplyr::filter(!is.na(draw2)) %>%
#       dplyr::select(-draw) %>%
#       dplyr::rename(draw=draw2) %>%
#       dplyr::mutate(mode=md)
#   }
#
# }
#
# length_draws <- dplyr::bind_rows(purrr::flatten(length_draw_list))
# write_csv(length_draws, file.path(iterative_input_data_cd, paste0("baseline_catch_at_length_new.csv")))
sf_size_data <- read_csv(file.path(iterative_input_data_cd, "baseline_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state == st, species=="sf", draw==dr) %>%
dplyr::filter(!is.na(fitted_prob)) %>%
dplyr::select(state, fitted_prob, length, mode)
bsb_size_data <- read_csv(file.path(iterative_input_data_cd, "baseline_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state == st, species=="bsb" , draw==dr) %>%
dplyr::filter(!is.na(fitted_prob)) %>%
dplyr::select(state, fitted_prob, length, mode)
scup_size_data <- read_csv(file.path(iterative_input_data_cd, "baseline_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state == st, species=="scup", draw==dr) %>%
dplyr::filter(!is.na(fitted_prob)) %>%
dplyr::select(state,  fitted_prob, length, mode)
# Pull in calibration comparison information about trip-level harvest/discard re-allocations
calib_comparison<-readRDS(file.path(iterative_input_data_cd, "calibrated_model_stats_new.rds")) %>%
dplyr::filter(state==st & draw==dr )
calib_comparison<-calib_comparison %>%
dplyr::rename(n_legal_rel_bsb=n_legal_bsb_rel,
n_legal_rel_scup=n_legal_scup_rel,
n_legal_rel_sf=n_legal_sf_rel,
n_sub_kept_bsb=n_sub_bsb_kept,
n_sub_kept_sf=n_sub_sf_kept,
n_sub_kept_scup=n_sub_scup_kept,
prop_legal_rel_bsb=prop_legal_bsb_rel,
prop_legal_rel_sf=prop_legal_sf_rel,
prop_legal_rel_scup=prop_legal_scup_rel,
prop_sub_kept_bsb=prop_sub_bsb_kept,
prop_sub_kept_sf=prop_sub_sf_kept,
prop_sub_kept_scup=prop_sub_scup_kept,
convergence_sf=sf_convergence,
convergence_bsb=bsb_convergence,
convergence_scup=scup_convergence)
##########
# List of species suffixes
species_suffixes <- c("sf", "bsb", "scup")
# Get all variable names
all_vars <- names(calib_comparison)
# Identify columns that are species-specific (contain _sf, _bsb, or _scup)
species_specific_vars <- all_vars[
str_detect(all_vars, paste0("(_", species_suffixes, ")$", collapse = "|"))
]
id_vars <- setdiff(all_vars, species_specific_vars)
calib_comparison<-calib_comparison %>%
dplyr::select(mode, all_of(species_specific_vars))
# Extract base variable names (without _sf, _bsb, _scup)
base_names <- unique(str_replace(species_specific_vars, "_(sf|bsb|scup)$", ""))
# Pivot the data longer on the species-specific columns
calib_comparison <- calib_comparison %>%
pivot_longer(
cols = all_of(species_specific_vars),
names_to = c(".value", "species"),
names_pattern = "(.*)_(sf|bsb|scup)"
) %>%
dplyr::distinct()
#  }
#}
calib_row <- calib_lookup[mode == md]
rel_to_keep_sf     <- calib_row$rel_to_keep_sf
keep_to_rel_sf     <- calib_row$keep_to_rel_sf
p_rel_to_keep_sf   <- calib_row$p_rel_to_keep_sf
p_keep_to_rel_sf   <- calib_row$p_keep_to_rel_sf
prop_sublegal_kept_sf <- calib_row$prop_sub_kept_sf
prop_legal_rel_sf     <- calib_row$prop_legal_rel_sf
all_keep_to_rel_sf <- as.integer(p_keep_to_rel_sf == 1)
sf_size_data <- sf_size_data[mode == md]
#Convert key data frames to data.table format early:
setDT(directed_trips)
setDT(catch_data)
setDT(calib_comparison)
setDT(sf_size_data)
setDT(bsb_size_data)
setDT(scup_size_data)
#Set up constants (unchanged):
floor_subl_sf_harv <- min(directed_trips$fluke_min_y2) - 3 * 2.54
mode_draw <- c("sh", "pr", "fh")
#Step 2: Reorganize calibration parameters#
calib_lookup <- calib_comparison %>%
dplyr::select(mode, species, rel_to_keep, keep_to_rel,
p_rel_to_keep, p_keep_to_rel,
prop_sub_kept, prop_legal_rel) %>%
tidyr::pivot_wider(
names_from = species,
values_from = c(rel_to_keep, keep_to_rel, p_rel_to_keep, p_keep_to_rel, prop_sub_kept, prop_legal_rel),
names_glue = "{.value}_{species}"
)
setDT(calib_lookup)
setkey(calib_lookup, mode)
calib_row <- calib_lookup[mode == md]
rel_to_keep_sf     <- calib_row$rel_to_keep_sf
keep_to_rel_sf     <- calib_row$keep_to_rel_sf
p_rel_to_keep_sf   <- calib_row$p_rel_to_keep_sf
p_keep_to_rel_sf   <- calib_row$p_keep_to_rel_sf
prop_sublegal_kept_sf <- calib_row$prop_sub_kept_sf
prop_legal_rel_sf     <- calib_row$prop_legal_rel_sf
all_keep_to_rel_sf <- as.integer(p_keep_to_rel_sf == 1)
# Filter length data by mode
sf_size_data <- sf_size_data[mode == md]
catch_data_md <- catch_data[mode == md]
sf_catch_check_md <- sum(catch_data_md$sf_cat)
which(is.na(catch_data_md))
sf_catch_data <- catch_data_md[sf_cat > 0]
sf_catch_data <- sf_catch_data[rep(1:.N, sf_cat)]
sf_catch_data[, fishid := .I]
# Sample fish lengths
sf_catch_data[, fitted_length := sample(sf_size_data$length, .N,
prob = sf_size_data$fitted_prob, replace = TRUE)]
# Identify keepable fish
sf_catch_data[, posskeep := as.integer(fitted_length >= fluke_min_y2)]
sf_catch_data[, csum_keep := ave(posskeep, tripid, date, mode, catch_draw, FUN = cumsum)]
sf_catch_data[, keep_adj := as.integer(posskeep == 1 & csum_keep <= fluke_bag_y2)]
sf_catch_data[, `:=`(keep = keep_adj, release = 1L - keep_adj)]
floor_subl_sf_harv
sf_catch_data[, subl_harv_indicator := as.integer(release == 1 & fitted_length >= floor_subl_sf_harv)]
sublegal_keeps <- sf_catch_data[subl_harv_indicator == 1]
base <- sf_catch_data[subl_harv_indicator == 0]
n_to_keep <- round(prop_sublegal_kept_sf * nrow(sublegal_keeps))
View(calib_comparison)
md
View(sublegal_keeps)
n_to_keep <- round(prop_sublegal_kept_sf * nrow(sublegal_keeps))
setDT(directed_trips)
setDT(catch_data)
setDT(calib_comparison)
setDT(bsb_size_data)
#Set up constants (unchanged):
floor_subl_bsb_harv <- min(directed_trips$bsb_min_y2) - 3 * 2.54
mode_draw <- c("sh", "pr", "fh")
#Step 2: Reorganize calibration parameters#
calib_lookup <- calib_comparison %>%
dplyr::select(mode, species, rel_to_keep, keep_to_rel,
p_rel_to_keep, p_keep_to_rel,
prop_sub_kept, prop_legal_rel) %>%
tidyr::pivot_wider(
names_from = species,
values_from = c(rel_to_keep, keep_to_rel, p_rel_to_keep, p_keep_to_rel, prop_sub_kept, prop_legal_rel),
names_glue = "{.value}_{species}"
)
setDT(calib_lookup)
setkey(calib_lookup, mode)
calib_row <- calib_lookup[mode == md]
rel_to_keep_bsb     <- calib_row$rel_to_keep_bsb
keep_to_rel_bsb     <- calib_row$keep_to_rel_bsb
p_rel_to_keep_bsb   <- calib_row$p_rel_to_keep_bsb
p_keep_to_rel_bsb   <- calib_row$p_keep_to_rel_bsb
prop_sublegal_kept_bsb <- calib_row$prop_sub_kept_bsb
prop_legal_rel_bsb     <- calib_row$prop_legal_rel_bsb
all_keep_to_rel_bsb <- as.integer(p_keep_to_rel_bsb == 1)
# Filter length data by mode
bsb_size_data <- bsb_size_data[mode == md]
# Filter catch data by mode
catch_data_md <- catch_data[mode == md]
bsb_catch_check_md <- sum(catch_data_md$bsb_cat)
bsb_catch_check_md
bsb_catch_data <- catch_data_md[bsb_cat > 0]
bsb_catch_data <- bsb_catch_data[rep(1:.N, bsb_cat)]
bsb_catch_data[, fishid := .I]
# Sample fish lengths
bsb_catch_data[, fitted_length := sample(bsb_size_data$length, .N,
prob = bsb_size_data$fitted_prob, replace = TRUE)]
# Identify keepable fish
bsb_catch_data[, posskeep := as.integer(fitted_length >= bsb_min_y2)]
bsb_catch_data[, csum_keep := ave(posskeep, tripid, date, mode, catch_draw, FUN = cumsum)]
bsb_catch_data[, keep_adj := as.integer(posskeep == 1 & csum_keep <= bsb_bag_y2)]
bsb_catch_data[, `:=`(keep = keep_adj, release = 1L - keep_adj)]
bsb_catch_data[, subl_harv_indicator := as.integer(release == 1 & fitted_length >= floor_subl_bsb_harv)]
rel_to_keep_bsb
keep_to_rel_bsb
kept <- bsb_catch_data[keep == 1]
base <- bsb_catch_data[keep == 0]
n_to_release <- round(prop_legal_rel_bsb * nrow(kept))
n_to_release
md
# Pull in calibration comparison information about trip-level harvest/discard re-allocations
calib_comparison<-readRDS(file.path(iterative_input_data_cd, "calibrated_model_stats_new.rds")) %>%
dplyr::filter(state==st & draw==dr )
View(calib_comparison)
# Data read for non-shiny run of predict_rec_catch.R
## Run this script prior to predict rec catch
#Lou's repos
iterative_input_data_cd="E:/Lou's projects/flukeRDM/flukeRDM_iterative_data"
input_data_cd="C:/Users/andrew.carr-harris/Desktop/MRIP_data_2025"
#check
############# To Run Individual
# Variables to change
#dr<-1
#st="NJ"
ndraws=50 #number of choice occasions to simulate per strata
library(magrittr)
############# To Run in Loop
#for (st in c("MA", "RI", "CT", "NY", "NJ", "DE", "MD", "VA", "NC")){
#  for (dr in 1:2){
# import necessary data
# For kim: We need to retain the SQ regulation variables.
#          As of now, the SQ regulations variables are the ones without subscripts.
#          I will copy these variables with the subscript _SQ to make this explicit.
#          The alternative regulations that will be adjusted by the users will be
#          have subscripts _y2 (note this is slightly different from cod and haddock 2024)
directed_trips<-feather::read_feather(file.path(iterative_input_data_cd, paste0("directed_trips_calibration_new_", st, ".feather"))) %>%
tibble::tibble() %>%
dplyr::filter(draw == dr) %>%
dplyr::select(mode, date,
bsb_bag, bsb_min, bsb_bag_y2, bsb_min_y2,
fluke_bag, fluke_min, fluke_bag_y2,fluke_min_y2,
scup_bag, scup_min, scup_bag_y2, scup_min_y2) %>%
dplyr::mutate(fluke_min_SQ=fluke_min, fluke_bag_SQ=fluke_bag,
bsb_min_SQ=bsb_min, bsb_bag_SQ=bsb_bag,
scup_min_SQ=scup_min, scup_bag_SQ=scup_bag)
#catch_data <- feather::read_feather(file.path(iterative_input_data_cd, paste0("proj_catch_draws_",st, "_", dr,".feather"))) %>%
#  dplyr::left_join(directed_trips, by=c("mode", "date"))
l_w_conversion <- readr::read_csv(file.path("C:/Users/andrew.carr-harris/Desktop/Git/flukeRDM/Data", "L_W_Conversion.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state==st)
# sf_size_data <- read_csv(file.path(iterative_input_data_cd, "projected_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
#   dplyr::filter(state == st, species=="sf", draw==dr) %>%
#   dplyr::filter(!is.na(fitted_prob)) %>%
#   dplyr::select(state, fitted_prob, length, mode)
#
# bsb_size_data <- read_csv(file.path(iterative_input_data_cd, "projected_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
#   dplyr::filter(state == st, species=="bsb" , draw==dr) %>%
#   dplyr::filter(!is.na(fitted_prob)) %>%
#   dplyr::select(state, fitted_prob, length, mode)
#
# scup_size_data <- read_csv(file.path(iterative_input_data_cd, "projected_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
#   dplyr::filter(state == st, species=="scup", draw==dr) %>%
#   dplyr::filter(!is.na(fitted_prob)) %>%
#   dplyr::select(state,  fitted_prob, length, mode)
calendar_adjustments <- readr::read_csv(
file.path(iterative_input_data_cd, paste0("proj_year_calendar_adjustments_new_", st, ".csv")), show_col_types = FALSE) %>%
dplyr::select(-state.y) %>%
dplyr::rename(state=state.x) %>%
dplyr::filter(state == st, draw==dr) %>%
dplyr::select(-dtrip, -dtrip_y2, -state, -draw)
# base-year trip outcomes
base_outcomes0 <- list()
n_choice_occasions0 <- list()
mode_draw <- c("sh", "pr", "fh")
for (md in mode_draw) {
# pull trip outcomes from the calibration year
base_outcomes0[[md]]<-feather::read_feather(file.path(iterative_input_data_cd, paste0("base_outcomes_new_", st, "_", md, "_", dr, ".feather"))) %>%
data.table::as.data.table()
base_outcomes0[[md]]<-base_outcomes0[[md]] %>%
dplyr::select(-domain2) %>%
dplyr::mutate(date_parsed=lubridate::dmy(date)) %>%
dplyr::select(-date)
# pull in data on the number of choice occasions per mode-day
n_choice_occasions0[[md]]<-feather::read_feather(file.path(iterative_input_data_cd, paste0("n_choice_occasions_new_", st,"_", md, "_", dr, ".feather")))
n_choice_occasions0[[md]]<-n_choice_occasions0[[md]] %>%
dplyr::mutate(date_parsed=lubridate::dmy(date)) %>%
dplyr::select(-date)
}
base_outcomes <- bind_rows(base_outcomes0)
n_choice_occasions <- bind_rows(n_choice_occasions0) %>%
dplyr::arrange(date_parsed, mode)
rm(base_outcomes0, n_choice_occasions0)
base_outcomes<-base_outcomes %>%
dplyr::arrange(date_parsed, mode, tripid, catch_draw)
catch_data <- base_outcomes %>%
dplyr::mutate(date_obj = as.Date(date_parsed, format = "%Y-%m-%d")) %>%
dplyr::mutate(date = format(date_obj, format = "%d%b%Y")|> tolower()) %>%
dplyr::select(-matches("beta")) %>%
dplyr::rename(sf_cat=tot_cat_sf_base, bsb_cat=tot_cat_bsb_base, scup_cat=tot_cat_scup_base) %>%
dplyr::select(-cost, -NJ_dummy, -age, -date_parsed, -date_obj,-total_trips_12, -matches("tot_keep"), -matches("tot_rel") ) %>%
dplyr::left_join(directed_trips, by=c("mode", "date"))
# Projected catch-at-length *note for Kim that this file now contains distn's by mode
# statez <- c("MA", "RI", "CT", "NY", "NJ", "DE", "MD", "VA", "NC")
# modez <- c("sh", "pr", "fh")
# length_draw_list<-list()
# length_draws_st_list<-list()
# for(st in statez){
#   for(md in modez){
#
#     good_draws<-read_excel(file.path(iterative_input_data_cd, "calibration_good_draws.xlsx")) %>%
#       dplyr::filter(state==st & mode==md)
#
#     length_draw_list[[md]][[st]]<-read_csv(file.path(iterative_input_data_cd, "baseline_catch_at_length.csv"), show_col_types = FALSE) %>%
#       dplyr::filter(state==st) %>%
#       dplyr::left_join(good_draws, by=c("state", "draw")) %>%
#       dplyr::filter(!is.na(draw2)) %>%
#       dplyr::select(-draw) %>%
#       dplyr::rename(draw=draw2) %>%
#       dplyr::mutate(mode=md)
#   }
#
# }
#
# length_draws <- dplyr::bind_rows(purrr::flatten(length_draw_list))
# write_csv(length_draws, file.path(iterative_input_data_cd, paste0("baseline_catch_at_length_new.csv")))
sf_size_data <- read_csv(file.path(iterative_input_data_cd, "baseline_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state == st, species=="sf", draw==dr) %>%
dplyr::filter(!is.na(fitted_prob)) %>%
dplyr::select(state, fitted_prob, length, mode)
bsb_size_data <- read_csv(file.path(iterative_input_data_cd, "baseline_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state == st, species=="bsb" , draw==dr) %>%
dplyr::filter(!is.na(fitted_prob)) %>%
dplyr::select(state, fitted_prob, length, mode)
scup_size_data <- read_csv(file.path(iterative_input_data_cd, "baseline_catch_at_length_new.csv"), show_col_types = FALSE)  %>%
dplyr::filter(state == st, species=="scup", draw==dr) %>%
dplyr::filter(!is.na(fitted_prob)) %>%
dplyr::select(state,  fitted_prob, length, mode)
# Pull in calibration comparison information about trip-level harvest/discard re-allocations
calib_comparison<-readRDS(file.path(iterative_input_data_cd, "calibrated_model_stats_new.rds")) %>%
dplyr::filter(state==st & draw==dr )
calib_comparison<-calib_comparison %>%
dplyr::rename(n_legal_rel_bsb=n_legal_bsb_rel,
n_legal_rel_scup=n_legal_scup_rel,
n_legal_rel_sf=n_legal_sf_rel,
n_sub_kept_bsb=n_sub_bsb_kept,
n_sub_kept_sf=n_sub_sf_kept,
n_sub_kept_scup=n_sub_scup_kept,
prop_legal_rel_bsb=prop_legal_bsb_rel,
prop_legal_rel_sf=prop_legal_sf_rel,
prop_legal_rel_scup=prop_legal_scup_rel,
prop_sub_kept_bsb=prop_sub_bsb_kept,
prop_sub_kept_sf=prop_sub_sf_kept,
prop_sub_kept_scup=prop_sub_scup_kept,
convergence_sf=sf_convergence,
convergence_bsb=bsb_convergence,
convergence_scup=scup_convergence)
##########
# List of species suffixes
species_suffixes <- c("sf", "bsb", "scup")
# Get all variable names
all_vars <- names(calib_comparison)
# Identify columns that are species-specific (contain _sf, _bsb, or _scup)
species_specific_vars <- all_vars[
str_detect(all_vars, paste0("(_", species_suffixes, ")$", collapse = "|"))
]
id_vars <- setdiff(all_vars, species_specific_vars)
calib_comparison<-calib_comparison %>%
dplyr::select(mode, all_of(species_specific_vars))
# Extract base variable names (without _sf, _bsb, _scup)
base_names <- unique(str_replace(species_specific_vars, "_(sf|bsb|scup)$", ""))
# Pivot the data longer on the species-specific columns
calib_comparison <- calib_comparison %>%
pivot_longer(
cols = all_of(species_specific_vars),
names_to = c(".value", "species"),
names_pattern = "(.*)_(sf|bsb|scup)"
) %>%
dplyr::distinct()
#  }
#}
